Thanks — I’ll evaluate your XPC-based system-wide window proxy proposal with those constraints: Accessibility permissions will be granted, it’s an internal developer utility, and the target platform is recent Apple Silicon macOS versions.

I’ll review its feasibility, expected reliability, limitations, and compare its capabilities with direct injection, especially regarding real-world window manipulation. I’ll get back to you shortly with a technical analysis.


# System-wide Window Modifier (Non-Injection) on macOS

A non-injection approach must rely entirely on public (and some private) APIs like CoreGraphics and Accessibility. In practice, one can poll windows via **CGWindowListCopyWindowInfo** (with options like `kCGWindowListOptionAll` to include all spaces) and then modify them via CGS or AX calls. However, *many window properties can only be changed by the window’s owning process*. For example, macOS provides **no public API to arbitrarily set “always-on-top” (floating) for another app’s window**. The private function `CGSSetWindowLevel` exists but can only be called by the window’s owner (or a special “universal owner” like the Dock). Similarly, preventing screen capture of a window is only possible by setting its `NSWindow.sharingType = NSWindowSharingNone` in-app – other processes cannot toggle another app’s sharingType. In short, detection via CGWindowList is broadly reliable (it will list most user windows across Spaces, excluding truly hidden or offscreen windows), but **modifying properties like topmost level, Space membership, or screenshot flags typically *cannot* be done externally**. Some window types (sheets, panels or system dialogs) may not appear in the list or may refuse external changes. The only workable “always-on-top” hack known (e.g. Afloat) injects code or uses a parent-child window trick, since without injection macOS will ignore CGS calls on foreign windows.

* **Window detection:** Using `CGWindowListCopyWindowInfo` with `kCGWindowListOptionAll` generally enumerates all visible and hidden windows in the user session, including those on other Desktops (Spaces). It reports properties like title, PID, layer, bounds, etc. (In practice, minimized or invisible windows may not appear if you use the *OnScreenOnly* flag.) You can filter by title, bundle ID, size, etc., but remember that **window IDs are ephemeral** – a window closed and reopened gets a new ID. Rules should therefore match on persistent attributes (app ID, title regex, size) rather than stored IDs.
* **Always-on-top / floating:** No supported API exists to float someone else’s window. Private CGS calls (e.g. `CGSSetWindowLevel(_CGSDefaultConnection(), wid, kCGFloatingWindowLevelKey)`) will error unless run by the window owner (macOS enforces that “only the owner of a window can manipulate it”). The only system-sanctioned “stay on top” windows are those owned by the app itself (e.g. iOS Simulator’s frontmost option, or Activity Monitor’s CPU-pane floating window). In our agent/daemon, we cannot mark a foreign window topmost – attempts to impersonate the Dock’s connection are brittle. In practice, one can only approximate “always on top” by ordering windows or making them child windows of a transparent always-on-top helper, but this is complex and may flicker.
* **Screen-capture prevention:** NSWindow has a `sharingType` property that can be set to `NSWindowSharingNone` to block screenshots, but this is an in-process setting. No CG or AX call lets you change another app’s sharingType. Thus, protecting an arbitrary window from capture without modifying its own code is effectively impossible with public APIs.
* **Spaces and Mission Control:** Controlling whether a window appears on all Spaces (via `NSWindow.collectionBehavior = .canJoinAllSpaces`) is likewise only done in-app. There is no external API to toggle a window’s Spaces membership. In Mission Control or Spaces switching, windows move and get hidden/revealed automatically by the OS; a user-mode agent cannot override that behavior.

## XPC Service and Permissions

Running the modifier logic in a separate XPC service is a standard approach. A **user-space XPC/daemon** (launched at login via a LaunchAgent or LaunchDaemon) can hold the Accessibility entitlement and continuously apply rules. This is viable and safer than injecting code – it runs with the user’s privileges and is subject to the same sandbox/entitlements as any process. With Accessibility permissions granted (as assumed), the XPC service can query and manipulate other processes’ windows through AX APIs (AXUIElement) and private CGS calls. In practice, **no additional entitlement** is needed beyond “accessibility” and being allowed as a launch agent. The XPC process cannot break SIP or hardened-runtime protections – it *cannot* load into or modify hardened processes, but it can still use window-server APIs (CGS) and AX. The main restrictions are simply those of the APIs themselves: for example, an AXObserver can listen for `kAXWindowCreated` on applications that allow it, but if a target process has set AX permissions to false, it won’t work. In short, an XPC helper with user-level credentials can persist rules and apply them, but it *cannot* bypass Apple’s process-isolation rules.

## Limitations vs. Injection-Based Methods

A purely external approach has known gaps compared to injection. Injection (e.g. via a SIMBL-like code plug-in) lets you call NSWindow methods directly, intercept events, and apply behaviors that are impossible otherwise. For example, you **cannot** make a window ignore clicks (non-activating interaction) or run custom animations without code inside the target process. AX’s `AXRaise` action can attempt to bring a window forward, but it is erratic (some users report it only works \~40% of the time), and it will always activate the app, not just that window. By contrast, an injected module could intercept the click event and prevent activation, or use `-[NSWindow orderFrontRegardless]` privately. Other behaviors like enforcing a window to *not* become key, or setting a window’s style mask, simply have no external equivalent.

Also, the APIs we use can be brittle. **Window ID volatility** means any rule based on a CGWindowID must be reapplied whenever windows are recreated. **AX and CGS APIs evolve:** for example, newer macOS versions restrict AX queries unless the process is properly authorized, and private APIs (CGS) may change without notice. Under SIP/hardened runtime, some CGS calls might fail unpredictably on sandboxed or notarized apps. Performance is also a factor: calling `CGWindowListCopyWindowInfo` frequently can be CPU-heavy if many windows exist, and AX attribute queries (e.g. retrieving a window’s size or role) are relatively slow. The system should cache results and only query differences, if possible. In summary, many *window-management tricks* (click-through windows, pinned windows, subtle event control) simply **cannot be achieved without injection**. Our non-injection daemon will do the *best it can* with the public/private APIs, but it will *not* replicate all behaviors that a true in-app or injected solution could.

## Performance and Stability

Polling windows must be balanced against CPU cost. **CGWindowListCopyWindowInfo** returns a CFArray of all window dictionaries on each call. Although not extremely heavy for a few dozen windows, on complex systems it can be costly if run too often. For reference, developers note that even scanning one app’s windows via `+[NSWindow windowNumbersWithOptions:]` is *orders of magnitude* faster than a full CGWindowList scan. In practice, one should minimize full scans: e.g. poll at a moderate rate (perhaps 2–5 times per second) and adjust down if the system is idle. Supplement with OS notifications where possible: NSWorkspace publishes app-activation and launch/termination events, and AXObservers can tell when a given app creates or closes a window. Use those to trigger a scan only when needed.

When modifying windows (via CGS or AX), do so efficiently. For example, only call `AXUIElementSetAttributeValue` on windows that actually match a rule, and beware that setting a position or size can be slow (the accessibility framework must talk to each app). If you only need window metadata (title, role, bounds) for matching, pull that from CGWindowList results directly instead of AX. Likewise, do not continuously set an attribute to the same value. Batch updates during idle periods, and avoid tight loops. This will help prevent jank or lag. Finally, test that the helper remains stable under load – frequent changes in window state (e.g. many windows opening/closing) could otherwise overwhelm the agent.

## Testing Scenarios and App Support

To validate coverage, test across a range of app frameworks and scenarios:

* **Frameworks:** Ensure it works on Electron (Chromium-based) apps, which use native NSWindow; on Tauri or other WebView-based apps; on pure AppKit/Cocoa apps; and on browsers like Safari/Chrome (WebKit-based). All of these create standard windows that appear in CGWindowList and (with permission) in AX. Also try Carbon or older-style apps if possible, though they are rare on Apple Silicon.
* **Window types:** Include normal document windows, floating panels, sheets/modal dialogs, system alerts, and HUDs. Some of these (especially sheets and HUDs) might have different roles or layers. Verify that the detector catches them (sheets usually appear as separate CGWindow entries attached to parent windows).
* **Rapid changes:** Simulate bursty window events – e.g. a script that opens and closes windows in quick succession – to ensure the daemon doesn’t miss rules or crash.
* **Spaces and Mission Control:** Move windows between Spaces (drag in Mission Control) and see if the modifier still applies rules. Use multiple Desktops and full-screen apps to check edge cases (CGWindowListOptionAll should still list those windows).
* **Multi-display:** Test with multiple monitors and different DPI scaling. Ensure coordinate-based rules handle display offsets correctly. If moving a window from one screen to another, confirm rules reapply.
* **Other UI features:** Things like auto-hiding tooltips, popovers, or notification banners should either be ignored or handled gracefully (e.g. they might not have titles or normal roles). Also test on Login/Lock screen – these are normally inaccessible to user agents.

Given our constraints (SIP on, hardened apps, no injection), the system is likely to be **partially effective**: it can reliably detect and reposition/resize many windows via AX and can bring apps front or hide them if accessibility allows. However, **always-on-top behavior and non-interactive overlay tricks will be fragile or impossible** without code insertion. In short, the architecture will work **for many common cases** (e.g. automatically moving chat windows, resizing browser windows, or hiding known offenders), but will have gaps for advanced behaviors. Proper testing as above will reveal the exact limits.

**Sources:** Apple’s CGWindow and AX documentation and community experiments. For example, setting `NSWindow.sharingType = NSWindowSharingNone` blocks screenshots, and StackOverflow answers confirm that only a window’s owner (or the system Dock) can change its level. Performance comments show that full-system window scans are relatively slow. These confirm that our non-injection approach can detect windows, but is inherently limited in what it can modify.
