// window_modifier.m - Enhanced for multi-process applications
#import <AppKit/AppKit.h>
#import <objc/runtime.h>
#import <dlfcn.h>
#import <CoreGraphics/CoreGraphics.h>
#include "window_registry.h"

// Declare NSWindow private methods
@interface NSWindow (PrivateMethods)
- (void)_setPreventsActivation:(BOOL)preventsActivation;
@end

// CGS Function and Type Declarations
typedef int CGSConnectionID;
typedef int CGSWindowID;
typedef uint64_t CGSNotificationID;
typedef void* CGSNotificationArg;
typedef void (*CGSNotifyConnectionProcPtr)(int type, void *data, uint32_t data_length, void *arg);

#define kCGSPreventsActivationTagBit (1 << 16)
#define kCGSWindowSharingNoneValue 0
#define kCGSWindowLevelForKey 2 // NSFloatingWindowLevel

// CGS Window Notification Types
enum {
    kCGSWindowDidCreateNotification = 1001,
    kCGSWindowDidDeminiaturizeNotification = 1002,
    kCGSWindowDidMiniaturizeNotification = 1003,
    kCGSWindowDidOrderInNotification = 1004,
    kCGSWindowDidOrderOutNotification = 1005,
    kCGSWindowDidReorderNotification = 1006,
    kCGSWindowDidResizeNotification = 1007,
    kCGSWindowDidUpdateNotification = 1008
};

// CGS Function typedefs
typedef CGSConnectionID (*CGSDefaultConnection_t)(void);
typedef CGError (*CGSSetWindowLevel_t)(CGSConnectionID, CGSWindowID, int);
typedef CGError (*CGSSetWindowSharingState_t)(CGSConnectionID, CGSWindowID, int);
typedef CGError (*CGSSetWindowTags_t)(CGSConnectionID, CGSWindowID, int*, int);
typedef CGError (*CGSClearWindowTags_t)(CGSConnectionID, CGSWindowID, int*, int);
typedef CGError (*CGSGetWindowTags_t)(CGSConnectionID, CGSWindowID, int*, int*);
typedef CGError (*CGSRegisterNotifyProc_t)(CGSNotifyConnectionProcPtr proc, int type, void *arg);
typedef CGError (*CGSGetOnScreenWindowList_t)(CGSConnectionID cid, CGSConnectionID targetCID, int maxCount, CGSWindowID *list, int *listCount);
typedef CGError (*CGSGetWindowLevel_t)(CGSConnectionID, CGSWindowID, int*);
typedef CGError (*CGSGetWindowOwner_t)(CGSConnectionID, CGSWindowID, CGSConnectionID*);
typedef CGError (*CGSGetConnectionPSN_t)(CGSConnectionID, ProcessSerialNumber*);
typedef CFArrayRef (*CGSCopyWindowDescriptionList_t)(CGSConnectionID cid, int windowID);
typedef CGError (*CGSGetConnectionID_t)(CGSConnectionID* cid);

// CGS Function pointers
static CGSDefaultConnection_t CGSDefaultConnection_ptr = NULL;
static CGSSetWindowLevel_t CGSSetWindowLevel_ptr = NULL;
static CGSSetWindowSharingState_t CGSSetWindowSharingState_ptr = NULL;
static CGSSetWindowTags_t CGSSetWindowTags_ptr = NULL;
static CGSClearWindowTags_t CGSClearWindowTags_ptr = NULL;
static CGSGetWindowTags_t CGSGetWindowTags_ptr = NULL;
static CGSRegisterNotifyProc_t CGSRegisterNotifyProc_ptr = NULL;
static CGSGetOnScreenWindowList_t CGSGetOnScreenWindowList_ptr = NULL;
static CGSGetWindowLevel_t CGSGetWindowLevel_ptr = NULL;
static CGSGetWindowOwner_t CGSGetWindowOwner_ptr = NULL;
static CGSGetConnectionPSN_t CGSGetConnectionPSN_ptr = NULL;
static CGSCopyWindowDescriptionList_t CGSCopyWindowDescriptionList_ptr = NULL;
static CGSGetConnectionID_t CGSGetConnectionID_ptr = NULL;

// Forward declarations to fix compilation issues
static NSDictionary *getWindowInfoWithCGS(CGSWindowID windowID);
static bool modifyWindowWithCGSInternal(CGSWindowID windowID, bool isRetry);

// Process role detection - simplified to three essential roles
typedef enum {
    PROCESS_ROLE_MAIN,       // Main application process
    PROCESS_ROLE_UI,         // Any UI rendering process (renderer, plugin, etc.)
    PROCESS_ROLE_UTILITY     // Background service process
} process_role_t;

// Global state - simplified
static NSRunningApplication *previousFrontmostApp = nil;
static window_registry_t *window_registry = NULL;
static bool is_cgs_monitor_active = false;
static process_role_t current_process_role = PROCESS_ROLE_MAIN;
static time_t process_start_time = 0;
static int modified_window_count = 0;
static const int STARTUP_PROTECTION_SECONDS = 3; // Simplified protection period
static const int UI_STARTUP_PROTECTION_SECONDS = 5; // Extra time for UI processes
static const int MAX_PROTECTED_WINDOWS = 2; // Limit for protected windows
static bool first_window_modification_attempted = false;

// Save previous app
static void saveFrontmostApp(void) {
    NSRunningApplication *frontApp = [[NSWorkspace sharedWorkspace] frontmostApplication];
    if (frontApp && ![frontApp.bundleIdentifier isEqualToString:[[NSBundle mainBundle] bundleIdentifier]]) {
        previousFrontmostApp = frontApp;
        printf("[Modifier] Saved frontmost app: %s\n", [frontApp.localizedName UTF8String]);
    }
}

// Return focus to previous app
static void restoreFrontmostApp(void) {
    if (previousFrontmostApp) {
        [previousFrontmostApp activateWithOptions:0];
        printf("[Modifier] Restored focus to: %s\n", [previousFrontmostApp.localizedName UTF8String]);
    }
}

// Load CGS functions
static bool loadCGSFunctions(void) {
    void *handle = dlopen("/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics", RTLD_LAZY);
    if (!handle) {
        printf("[Modifier] Error: Failed to open CoreGraphics framework\n");
        return false;
    }
    
    // Load core CGS functions
    CGSDefaultConnection_ptr = (CGSDefaultConnection_t)dlsym(handle, "_CGSDefaultConnection");
    if (!CGSDefaultConnection_ptr) {
        CGSDefaultConnection_ptr = (CGSDefaultConnection_t)dlsym(handle, "CGSMainConnectionID");
    }
    
    CGSSetWindowLevel_ptr = (CGSSetWindowLevel_t)dlsym(handle, "CGSSetWindowLevel");
    CGSSetWindowSharingState_ptr = (CGSSetWindowSharingState_t)dlsym(handle, "CGSSetWindowSharingState");
    CGSSetWindowTags_ptr = (CGSSetWindowTags_t)dlsym(handle, "CGSSetWindowTags");
    CGSClearWindowTags_ptr = (CGSClearWindowTags_t)dlsym(handle, "CGSClearWindowTags");
    CGSGetWindowTags_ptr = (CGSGetWindowTags_t)dlsym(handle, "CGSGetWindowTags");
    
    // Load CGS functions for window detection
    CGSRegisterNotifyProc_ptr = (CGSRegisterNotifyProc_t)dlsym(handle, "CGSRegisterNotifyProc");
    CGSGetOnScreenWindowList_ptr = (CGSGetOnScreenWindowList_t)dlsym(handle, "CGSGetOnScreenWindowList");
    CGSGetWindowLevel_ptr = (CGSGetWindowLevel_t)dlsym(handle, "CGSGetWindowLevel");
    CGSGetWindowOwner_ptr = (CGSGetWindowOwner_t)dlsym(handle, "CGSGetWindowOwner");
    CGSGetConnectionPSN_ptr = (CGSGetConnectionPSN_t)dlsym(handle, "CGSGetConnectionPSN");
    CGSCopyWindowDescriptionList_ptr = (CGSCopyWindowDescriptionList_t)dlsym(handle, "CGSCopyWindowDescriptionList");
    CGSGetConnectionID_ptr = (CGSGetConnectionID_t)dlsym(handle, "CGSGetConnectionID");
    
    bool success = (CGSDefaultConnection_ptr != NULL && 
                    CGSSetWindowLevel_ptr != NULL && 
                    CGSSetWindowSharingState_ptr != NULL && 
                    CGSSetWindowTags_ptr != NULL);
    
    printf("[Modifier] CGS core functions loaded: %s\n", success ? "Success" : "Failed");
    
    bool detection_success = (CGSRegisterNotifyProc_ptr != NULL && 
                              CGSGetOnScreenWindowList_ptr != NULL);
    
    printf("[Modifier] CGS detection functions loaded: %s\n", detection_success ? "Success" : "Failed");
    
    return success;
}

// Check if a window is ready for modification
static bool isWindowReadyForModification(CGSWindowID windowID) {
    if (!CGSDefaultConnection_ptr || !CGSCopyWindowDescriptionList_ptr) {
        return true; // If we can't check, assume it's ready
    }
    
    NSDictionary *windowInfo = getWindowInfoWithCGS(windowID);
    if (!windowInfo) {
        return false; // Can't get window info, not ready
    }
    
    // Check window properties more comprehensively
    NSNumber *alpha = windowInfo[@"kCGSWindowAlpha"];
    NSString *windowLayer = windowInfo[@"kCGSWindowLayer"];
    NSNumber *width = windowInfo[@"kCGSWindowWidth"];
    NSNumber *height = windowInfo[@"kCGSWindowHeight"];
    NSString *windowType = windowInfo[@"kCGSWindowType"];
    NSNumber *isOnAllSpaces = windowInfo[@"kCGSWindowIsOnAllWorkspaces"];
    NSString *sharingState = windowInfo[@"kCGSWindowSharingState"];
    NSString *windowTitle = windowInfo[@"kCGSWindowTitle"];
    
    // Log extended window information for debugging
    printf("[Modifier] Window %d readiness check: alpha=%.2f, layer=%s, size=%dx%d, type=%s\n",
           windowID, 
           [alpha doubleValue],
           [windowLayer UTF8String],
           [width intValue], [height intValue],
           [windowType UTF8String]);
    
    if (windowTitle) {
        printf("[Modifier] Window %d title: %s\n", windowID, [windowTitle UTF8String]);
    }
    
    // More strict requirements for window readiness:
    // 1. Window must be visible (alpha > 0)
    BOOL isVisible = [alpha doubleValue] > 0.0;
    
    // 2. Window must be on the main layer (0) - higher layers are for special windows
    // Layer 0 = normal window, Layer 1000 = system UI, Layer 1001 = dock, etc.
    BOOL isMainLayer = [windowLayer intValue] == 0;
    
    // 3. Window must have reasonable dimensions (not tiny utility or offscreen)
    BOOL hasReasonableSize = [width intValue] > 100 && [height intValue] > 100;
    
    // 4. Check window type (if available)
    BOOL isNormalWindowType = YES;
    if (windowType) {
        // Avoid special window types
        isNormalWindowType = !([windowType containsString:@"MenuWindow"] || 
                              [windowType containsString:@"AlertWindow"] ||
                              [windowType containsString:@"DragWindow"] ||
                              [windowType containsString:@"OverlayWindow"] ||
                              [windowType containsString:@"HelpWindow"]);
    }
    
    // 5. Avoid windows that are set to appear on all spaces (often utilities)
    BOOL isNotOnAllSpaces = (isOnAllSpaces == nil) || [isOnAllSpaces boolValue] == NO;
    
    // 6. Check sharing state for special windows
    BOOL hasNormalSharing = YES;
    if (sharingState) {
        // Some special utility windows have unusual sharing states
        int sharingStateVal = [sharingState intValue];
        hasNormalSharing = (sharingStateVal != 1 && sharingStateVal != 2);
    }
    
    // Combine all checks for a comprehensive window readiness assessment
    return isVisible && isMainLayer && hasReasonableSize && 
           isNormalWindowType && isNotOnAllSpaces && hasNormalSharing;
}

// Internal implementation of window modification (without retry handling)
static bool modifyWindowWithCGSInternal(CGSWindowID windowID, bool isRetry) {
    if (!CGSDefaultConnection_ptr || windowID == 0) return false;
    
    // Check if we already modified this window in any process
    if (window_registry && registry_is_window_modified(window_registry, windowID)) {
        if (!isRetry) {
            printf("[Modifier] Window %d already modified, skipping\n", windowID);
        }
        return true;
    }
    
    CGSConnectionID cid = CGSDefaultConnection_ptr();
    bool success = true;
    
    // 1. Apply non-activating (prevent stealing focus)
    if (CGSSetWindowTags_ptr) {
        int tags[1] = { kCGSPreventsActivationTagBit };
        CGError err = CGSSetWindowTags_ptr(cid, windowID, tags, 1);
        
        if (err != 0) {
            printf("[Modifier] Warning: Failed to set non-activating for window %d (error: %d)\n", 
                   windowID, err);
            success = false;
        } else {
            printf("[Modifier] Set window %d as non-activating\n", windowID);
        }
    }
    
    // 2. Always-on-top (floating window level)
    if (CGSSetWindowLevel_ptr) {
        CGError err = CGSSetWindowLevel_ptr(cid, windowID, kCGSWindowLevelForKey);
        
        if (err != 0) {
            printf("[Modifier] Warning: Failed to set window level for window %d (error: %d)\n", 
                   windowID, err);
            success = false;
        } else {
            printf("[Modifier] Set window %d as always-on-top\n", windowID);
        }
    }
    
    // 3. Screen capture bypass
    if (CGSSetWindowSharingState_ptr) {
        CGError err = CGSSetWindowSharingState_ptr(cid, windowID, kCGSWindowSharingNoneValue);
        
        if (err != 0) {
            printf("[Modifier] Warning: Failed to set screen capture bypass for window %d (error: %d)\n", 
                   windowID, err);
            success = false;
        } else {
            printf("[Modifier] Set window %d with screen capture bypass\n", windowID);
        }
    }
    
    if (success && window_registry) {
        // Mark the window as modified in our registry
        registry_mark_window_modified(window_registry, windowID);
        
        // Track that we've modified another window
        modified_window_count++;
    }
    
    return success;
}

// Detect process role based on executable path and other heuristics
static process_role_t detectProcessRole(void) {
    const char* processPath = getprogname();
    if (!processPath) {
        return PROCESS_ROLE_MAIN; // Default to main if we can't determine
    }
    
    // Extract process name from path
    const char* processName = strrchr(processPath, '/');
    if (processName) {
        processName++; // Skip '/'
    } else {
        processName = processPath;
    }
    
    // Enhanced detection for Discord and Electron apps
    // Discord has multiple renderers, GPU helpers, network services, etc.
    
    // Check for utility/helper processes by name patterns (expanded for Discord)
    if ((strstr(processName, "Helper") || strstr(processName, "helper")) && (
        strstr(processName, "GPU") || 
        strstr(processName, "Gpu") ||
        strstr(processName, "gpu") ||
        strstr(processName, "Utility") || 
        strstr(processName, "utility") ||
        strstr(processName, "Plugin") || 
        strstr(processName, "plugin") ||
        strstr(processName, "crashpad") ||
        strstr(processName, "Crashpad") ||
        strstr(processName, "Network") ||
        strstr(processName, "network") ||
        strstr(processName, "Service") ||
        strstr(processName, "service")
    )) {
        printf("[Modifier] Detected utility process: %s\n", processName);
        return PROCESS_ROLE_UTILITY;
    }
    
    // Check for renderer processes - expanded for all Electron apps
    if (strstr(processName, "Renderer") || 
        strstr(processName, "renderer") ||
        strstr(processName, "WebProcess") ||
        strstr(processName, "WebContent")) {
        printf("[Modifier] Detected renderer process: %s\n", processName);
        return PROCESS_ROLE_UI;
    }
    
    // Special handling for Discord/Electron plugin processes
    if (strstr(processName, "Discord") && strstr(processPath, "Plugin")) {
        printf("[Modifier] Detected plugin process: %s\n", processName);
        return PROCESS_ROLE_UI;
    }
    
    // If it's the main executable of an app bundle, it's likely the main process
    if (strstr(processPath, ".app/Contents/MacOS/")) {
        printf("[Modifier] Detected main process: %s\n", processName);
        return PROCESS_ROLE_MAIN;
    }
    
    // If we can't determine definitely, log more info
    printf("[Modifier] Unknown process role - path: %s, name: %s\n", 
           processPath, processName);
    
    return PROCESS_ROLE_MAIN; // Default to main process for unknown roles
}

// Check if a window belongs to a network service or critical system process
static bool isUtilityWindow(CGSWindowID windowID) {
    NSDictionary *windowInfo = getWindowInfoWithCGS(windowID);
    if (!windowInfo) {
        return false;
    }
    
    // Extract comprehensive window metadata
    NSString *windowName = windowInfo[@"kCGSWindowTitle"];
    NSNumber *alpha = windowInfo[@"kCGSWindowAlpha"];
    NSNumber *width = windowInfo[@"kCGSWindowWidth"];
    NSNumber *height = windowInfo[@"kCGSWindowHeight"];
    NSString *windowLayer = windowInfo[@"kCGSWindowLayer"];
    NSString *sharingState = windowInfo[@"kCGSWindowSharingState"];
    NSString *windowType = windowInfo[@"kCGSWindowType"];
    NSNumber *isOnAllSpaces = windowInfo[@"kCGSWindowIsOnAllWorkspaces"];
    NSString *ownerName = windowInfo[@"kCGSOw
